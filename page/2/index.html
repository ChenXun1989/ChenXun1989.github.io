<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="baidu-site-verification" content="codeva-8ePGCewncs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.chenxun.wiki","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta property="og:type" content="website"><meta property="og:title" content="陈公子的博客"><meta property="og:url" content="https://www.chenxun.wiki/page/2/index.html"><meta property="og:site_name" content="陈公子的博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="陈公子"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.chenxun.wiki/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>陈公子的博客 - 文字可以宣泄过往，但终究写不出流年</title><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">陈公子的博客</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">文字可以宣泄过往，但终究写不出流年</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">31</span></a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/baidusitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">陈公子</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062059976/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062059976/" class="post-title-link" itemprop="url">RPC框架设计</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 07:08:31" itemprop="dateCreated datePublished" datetime="2023-06-20T07:08:31+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="RPC框架设计"><a href="#RPC框架设计" class="headerlink" title="RPC框架设计"></a>RPC框架设计</h1><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<br>RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br><strong>代码地址：<a target="_blank" rel="noopener" href="https://github.com/ChenXun1989/netty-rpc">https://github.com/ChenXun1989/netty-rpc</a></strong></p><h2 id="透明化RPC"><a href="#透明化RPC" class="headerlink" title="透明化RPC"></a>透明化RPC</h2><p>一个RPC服务调用有以下几个步骤</p><ol><li>服务消费方（client）调用以本地调用方式调用服务</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体</li><li>client stub找到服务地址，并将消息发送到服务端</li><li>server stub收到消息后进行解码</li><li>server stub根据解码结果调用本地的服务</li><li>本地服务执行并将结果返回给server stub</li><li>server stub将返回结果打包成消息并发送至消费方</li><li>client stub接收到消息，并进行解码</li><li>服务消费方得到最终结果</li></ol><p><strong>透明的RPC测试把2-8步骤全部封装起来，消费方只需要执行第一个步骤，并等待返回结果就行。</strong></p><p>透明化RPC具体调用过程</p><img src="/2023062059976/1.png" title="image"><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><ul><li>动态代理（客户端） 主要实现有两种JDK动态代理和cglib</li><li>reqeust对象 主要包含 服务方法签名和参数</li><li>repsone对象 主要包含服务方法处理结果和异常</li><li>序列化和反序列化 主要在 reqeust和respone对象，该demo采用protobuf实现</li><li>socket通讯 该demo采用netty4实现。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062063138/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062063138/" class="post-title-link" itemprop="url">IOC容器设计</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 07:04:16" itemprop="dateCreated datePublished" datetime="2023-06-20T07:04:16+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="IOC容器设计"><a href="#IOC容器设计" class="headerlink" title="IOC容器设计"></a>IOC容器设计</h1><p>提供getBean接口，支持依赖注入<br><strong>示例代码地址： <a target="_blank" rel="noopener" href="https://github.com/ChenXun1989/ioc-framework">https://github.com/ChenXun1989/ioc-framework</a></strong></p><h2 id="IOC容器主要模块"><a href="#IOC容器主要模块" class="headerlink" title="IOC容器主要模块"></a>IOC容器主要模块</h2><ul><li>ApplicationContext，IOC容器上下文，持有对象Map</li><li>BeanFactory 每一个类型（class） 对应一BeanFactory，提供获取类实现的接口，属性注入接口</li><li>CompentScan 收集相关配置信息，主要分xml和注解扫描两种</li></ul><h2 id="IOC容器启动过程"><a href="#IOC容器启动过程" class="headerlink" title="IOC容器启动过程"></a>IOC容器启动过程</h2><p>ApplicationContext 创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ApplicationContext</span>(<span class="string">&quot;com.chenxun.framework.example.entity&quot;</span>);</span><br><span class="line">Student s=(Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">s.test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CompentScan 收集相关配置信息，解析出被ioc容器托管的class集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String &gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(String packageName)</span>&#123;</span><br><span class="line">String parent=	System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">parent=parent+<span class="string">&quot;/src/main/java&quot;</span>;</span><br><span class="line">System.out.println(parent);</span><br><span class="line">String child=packageName.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">File f=<span class="keyword">new</span> <span class="title class_">File</span>(parent ,child);</span><br><span class="line"><span class="keyword">for</span>(File c:f.listFiles())&#123;</span><br><span class="line"><span class="keyword">if</span>(c.getName().endsWith(<span class="string">&quot;.java&quot;</span>))&#123;</span><br><span class="line">list.add(packageName+<span class="string">&quot;.&quot;</span>+c.getName().substring(<span class="number">0</span>,c.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> List&lt;String &gt; getList()&#123;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建对应类的BeanFactory</li><li>BeanFactory通过反射创建默认class默认实例对象</li><li>把创建完的对象放入ApplicationContext持有的对象Map</li><li>遍历beanFactory的Map，调用setProperties接口来完成依赖注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">compentScan.scan(backPackage);</span><br><span class="line"><span class="keyword">for</span>(String clasName:compentScan.getList())&#123;</span><br><span class="line">Class cls=Class.forName(clasName);</span><br><span class="line">Compent c=(Compent) cls.getAnnotation(Compent.class);</span><br><span class="line"><span class="keyword">if</span>(c!=<span class="literal">null</span>)&#123;</span><br><span class="line">String key=c.value();			</span><br><span class="line">BeanFactory bf=<span class="keyword">new</span> <span class="title class_">SimpleBeanFactory</span>(cls);</span><br><span class="line">beanFactorys.put(cls, bf);</span><br><span class="line">map.put(key, bf.getBean());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Class, BeanFactory&gt; entry :beanFactorys.entrySet())&#123;</span><br><span class="line">entry.getValue().setProperties(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>先创建对象，再做依赖注入</li><li>容器里面是原生对象还是代理对象，取决于beanfatory返回的对象实例</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062026971/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062026971/" class="post-title-link" itemprop="url">mybatis源码分析（一）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:59:40" itemprop="dateCreated datePublished" datetime="2023-06-20T06:59:40+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="mybatis源码分析（一）"><a href="#mybatis源码分析（一）" class="headerlink" title="mybatis源码分析（一）"></a>mybatis源码分析（一）</h1><h2 id="sqlSessionFactory对象"><a href="#sqlSessionFactory对象" class="headerlink" title="sqlSessionFactory对象"></a>sqlSessionFactory对象</h2><p>sqlSessionFactory 是mybatis 核心配置类，管理mybatis全局配置。</p><h2 id="sqlSession接口"><a href="#sqlSession接口" class="headerlink" title="sqlSession接口"></a>sqlSession接口</h2><p>一个或者多个sql操作的执行单元。实现一个完整的sql操作。依赖sqlSessionFactory创建</p><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><p>对应jdbc底层一个完整的sql操作。sqlSession 实际通过Executor执行sql操作</p><h2 id="MapperProxy类"><a href="#MapperProxy类" class="headerlink" title="MapperProxy类"></a>MapperProxy类</h2><p>代理实现mybatis的客户端mapper接口</p><h2 id="MapperMethod类"><a href="#MapperMethod类" class="headerlink" title="MapperMethod类"></a>MapperMethod类</h2><p>对应客户端代码的mapper接口里面的一个方法。该实例缓存了。</p><h2 id="StatementHandler接口"><a href="#StatementHandler接口" class="headerlink" title="StatementHandler接口"></a>StatementHandler接口</h2><p>jdbc Statement的装饰器</p><h2 id="ResultSetHandler接口"><a href="#ResultSetHandler接口" class="headerlink" title="ResultSetHandler接口"></a>ResultSetHandler接口</h2><p>jdbc resultSet的装饰器</p><h2 id="mybaits执行orm操作细节"><a href="#mybaits执行orm操作细节" class="headerlink" title="mybaits执行orm操作细节"></a>mybaits执行orm操作细节</h2><img src="/2023062026971/1.png" title="image"><p><strong>sqlsession的close 方法会关闭底层jdbc connection</strong></p><h2 id="mybatis插件机制"><a href="#mybatis插件机制" class="headerlink" title="mybatis插件机制"></a>mybatis插件机制</h2><p>mybatis插件是基于代理实现的，具体支持一下四个接口</p><ul><li>Executor</li><li>ParameterHandler</li><li>ResultSetHandler</li><li>StatemetHandler</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/202306203579/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/202306203579/" class="post-title-link" itemprop="url">java线程状态</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:46:26" itemprop="dateCreated datePublished" datetime="2023-06-20T06:46:26+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h1><p>java线程有以下几个状态</p><ul><li>new 初始状态</li><li>runnable 运行状态（包括就绪和运行）</li><li>blocked 阻塞状态</li><li>waiting 等待状态,需要其他线程特定动作唤醒（通知或者中断）</li><li>time-waiting 超时等待状态，可以在指定时间内返回。</li><li>terminated 终止状态</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>java构造线程有两种办法,Thread类和Runnable接口,Thread的类本身实现了Runnable接口。<br>常见的作法,是通过thread类的public Thread(Runnable target)构造函数来创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>thread类的初始话代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params"><span class="type">long</span> stackSize, AccessControlContext acc)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">g = security.getThreadGroup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">g.checkAccess();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">        security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">g.addUnstarted();</span><br><span class="line"><span class="built_in">this</span>.group = g;</span><br><span class="line"><span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line"><span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line"><span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">    <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"><span class="built_in">this</span>.target = target;</span><br><span class="line">setPriority(priority);</span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"><span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">   </span><br><span class="line">tid = nextThreadID();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这段代码可以看出以下几点<br>当前线程为创建线程的父线程<br>child线程继承parent的Daemon、优先级、和加载资源的contextClassLoader和一个可以继承的ThreadLocal。<br><strong>Daemon线程（后台线程）的finally块代码不会执行</strong></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>Thread类的start方法起来运行线程。底层通过调用navate方法来运行线程。<br><strong>start（）方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码</strong><br><strong>run（）方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码</strong></p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>线程执行到monitorenter保护的代码快时，会去获取monitorenter对应的对象锁，如未获取，则该线程进入同步队列，状态为阻塞。<br><strong>任意对象都拥有自己的monitor，包括class对象。</strong></p><h2 id="等待-x2F-唤醒"><a href="#等待-x2F-唤醒" class="headerlink" title="等待&#x2F;唤醒"></a>等待&#x2F;唤醒</h2><p>线程等待的方法主要有下面几种</p><ul><li>object.wait() &#x2F; object.wait(long)</li><li>object.join() &#x2F; object.join(long)</li><li>lockSupport.park() &#x2F; lockSupport.park(long)</li></ul><p>当线程调用某个对象的wati方法，进入等待。当另一个线程调用该对象的notify()&#x2F;notifyall()方法，之前等待的线程唤醒。<br>线程唤醒的方法注意下面几种</p><ul><li>object.notify()&#x2F;notifyAll()</li><li>lockSupport.unpark(Thread)</li></ul><p><strong>调用对象wait或者notify方法的前题是获取当前对象的内置锁。</strong></p><p>通过wait&#x2F;notify设计的经典作法<br>等待方：</p><ul><li>获取对象锁</li><li>条件检查</li><li>为假则等待</li><li>为真则执行后面的逻辑<br>唤醒方：</li><li>获取对象锁</li><li>改变条件</li><li>通知所有等待在对象的线程</li></ul><p><strong>条件变量用volatile修饰来保证可见性</strong></p><h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>线程对应的run方法运行完毕，则线程终止。不推荐使用stop来终止线程。可以通过状态变量来终止线程。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/202306209196/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/202306209196/" class="post-title-link" itemprop="url">Buffer详解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:38:07" itemprop="dateCreated datePublished" datetime="2023-06-20T06:38:07+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Buffer详解"><a href="#Buffer详解" class="headerlink" title="Buffer详解"></a>Buffer详解</h1><p>java中的nio由channel,buffer,Selector组成核心API。<br>Buffer是一个继承于object的抽象类,主要有下面几种。</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>基本覆盖了基本类型的支持，看下byteBuffer的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 间接缓冲区</span></span><br><span class="line">ByteBuffer bf1=ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 直接缓冲区</span></span><br><span class="line">ByteBuffer bf2=ByteBuffer.allocateDirect(<span class="number">16</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ByteBuffer提供两种方式来获取缓存区内存，间接或者直接。<br>字节缓冲区要么是直接的，要么是非直接的。<br>如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I&#x2F;O 操作。<br>也就是说，在每次调用基础操作系统的一个本机 I&#x2F;O 操作之前（或之后），<br>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。<br><strong>直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，不会被GC回收。</strong><br>间接缓冲区与本地操作系统低层次的i&#x2F;o交互需要一个中间缓冲区来实现，因此性能比直接缓存区要低。<br>直接缓冲区通过sun.misc.Unsafe类调用jni本地方法来分配内存。<br>因为绕过jvm,因此分配内存的开销较大，并且需要用户自己当成普通资源来主动释放。<br>堆外内存的分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"><span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line"><span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">Bits.reserveMemory(size, cap);</span><br><span class="line"><span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">base = unsafe.allocateMemory(size);</span><br><span class="line">&#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">Bits.unreserveMemory(size, cap);</span><br><span class="line"><span class="keyword">throw</span> x;</span><br><span class="line">&#125;</span><br><span class="line">unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">// Round up to page boundary</span></span><br><span class="line">address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">address = base;</span><br><span class="line">&#125;</span><br><span class="line">cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出通过unsafe.allocateMemory方法来分配堆外内存，同时创建一个对应的Cleaner<br>sun.misc.Cleaner.create方法两个参数。</p><ul><li>需要监控的堆内存对象，就是堆外内存关联的对象。</li><li>程序释放资源的回调。</li></ul><p>当JVM进行GC的时候，如果发现我们监控的对象，不存在强引用了，(Cleaner本身是幽灵引用)，<br>就会调用预先绑定的回调方法，我们一般在回调方法里面释放堆外内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deallocator</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> address;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Deallocator</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> size, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line"><span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line"><span class="built_in">this</span>.size = size;</span><br><span class="line"><span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Paranoia</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">unsafe.freeMemory(address);</span><br><span class="line">address = <span class="number">0</span>;</span><br><span class="line">Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终通过unsafe类提供freeMemory来释放之前分配的对外内存。<br><strong>堆外内存大小可以通过jvm启动参数限制： -XX:MaxDirectMemorySize</strong></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/20230620302/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/20230620302/" class="post-title-link" itemprop="url">并发容器和同步容器</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:35:58" itemprop="dateCreated datePublished" datetime="2023-06-20T06:35:58+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="并发容器和同步容器"><a href="#并发容器和同步容器" class="headerlink" title="并发容器和同步容器"></a>并发容器和同步容器</h1><p>java的同步容器有Vector和Hashtable。<br>vecotor和hashtbale通过synchronized来锁定对容器状态的访问，例如get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"><span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同步容器类是线程安全的，但复合操作不一定是线程安全的，需要客户端额外加锁来保证线程安全。</p><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>同步容器将所有对容器状态的访问都串行化，以实现线程安全。这种性能比较低，<br>java5.0 引入了并发容器,在java.util.concurrent包下面</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。<br><strong>ConcurrentHashMap是弱一致性的，get，clear都是弱一致性的</strong></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062035937/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062035937/" class="post-title-link" itemprop="url">synchronized原理解析</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:30:26" itemprop="dateCreated datePublished" datetime="2023-06-20T06:30:26+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="synchronized原理解析"><a href="#synchronized原理解析" class="headerlink" title="synchronized原理解析"></a>synchronized原理解析</h1><h2 id="synchronized的三种方式"><a href="#synchronized的三种方式" class="headerlink" title="synchronized的三种方式"></a>synchronized的三种方式</h2><p>对于普通同步方法,锁的是当前实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态方同步方法，锁的是当前类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于同步方法快，锁的是synchronized括号里的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">	<span class="comment">//do something	</span></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><p>jdk1.6之后，synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级。</p><ul><li>偏向锁： 存在java对象头里面。</li><li>轻量级锁：存在当前线程的栈帧里面</li><li>重量级锁： 存在当前对象的monitor对象里面</li></ul><p>锁升级过程：</p><ul><li>无锁状态到偏向锁，当前线程通过cas修改java对象头的锁标志位。</li><li>谝向锁到轻量级锁, 当前线程把java对象头的锁信息copy到栈帧里面</li><li>轻量级锁到重量级锁，把栈帧里面的锁信息copy到对象的monitor里面。</li><li>偏向锁和轻量级锁采用cas自旋修改锁状态，重量级锁通过线程信号来实现*</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062051308/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062051308/" class="post-title-link" itemprop="url">volatile原理解析</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:18:09" itemprop="dateCreated datePublished" datetime="2023-06-20T06:18:09+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="volatile原理解析"><a href="#volatile原理解析" class="headerlink" title="volatile原理解析"></a>volatile原理解析</h1><h2 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h2><p>jsr133规范对volatile语义进行了增强，明确保证了可见性和有序性。</p><p><strong>volatile不保证原子性</strong></p><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。<br>Java语言提供了volatile，在某些情况下比锁更加方便。<br>如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p><h2 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h2><p>jmm为了保证volatile的语义中的有序性，通过内存屏障来禁止指令重排序<br>JMM基于保守策略的JMM内存屏障插入策略</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个SotreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障</li></ul><p>x86处理器仅仅会对写-读操作做重排序,因此在x86中，JMM仅需在volatile后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义</p><h2 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h2><p>对于volatile修饰的变量，jvm虚拟机保证从主内存加载到线程工作内存的值是最新的。<br>从内存语义的角度来看</p><ul><li>volatile的写-读与锁的释放-获取有相同的内存效果</li><li>volatile写和锁的释放有相同的内存语义</li><li>volatile读与锁的获取有相同的内存语义</li></ul><p>当线程释放锁的时候，JMM会把线程对应的本地内存中的共享变量刷新到主内存中<br>当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p><h2 id="volatile的使用前提"><a href="#volatile的使用前提" class="headerlink" title="volatile的使用前提"></a>volatile的使用前提</h2><ul><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062012456/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062012456/" class="post-title-link" itemprop="url">java内存结构和内存模型</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 06:13:32" itemprop="dateCreated datePublished" datetime="2023-06-20T06:13:32+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="java内存结构和内存模型"><a href="#java内存结构和内存模型" class="headerlink" title="java内存结构和内存模型"></a>java内存结构和内存模型</h1><h2 id="java内存结构"><a href="#java内存结构" class="headerlink" title="java内存结构"></a>java内存结构</h2><p>java内存结构大致分为以下几个区域</p><img src="/2023062012456/1.png" title="image"><h2 id="PC寄存器-x2F-程序计数器"><a href="#PC寄存器-x2F-程序计数器" class="headerlink" title="PC寄存器&#x2F;程序计数器"></a>PC寄存器&#x2F;程序计数器</h2><p>严格来说是一个数据结构，用于保存当前正在执行的程序的内存地址，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。 为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。</p><h2 id="Java栈-Java-Stack"><a href="#Java栈-Java-Stack" class="headerlink" title="Java栈 Java Stack"></a>Java栈 Java Stack</h2><p>java栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。</p><p>由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h2 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h2><p>堆是JVM所管理的内存中最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。 堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。</p><h2 id="方法区Method-Area"><a href="#方法区Method-Area" class="headerlink" title="方法区Method Area"></a>方法区Method Area</h2><p>方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation，大小可以通过参数来设置,可以通过-XX:PermSize指定初始值，-XX:MaxPermSize指定最大值。</p><h2 id="常量池Constant-Pool"><a href="#常量池Constant-Pool" class="headerlink" title="常量池Constant Pool"></a>常量池Constant Pool</h2><p>常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和应用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符</p><h2 id="本地方法栈Native-Method-Stack"><a href="#本地方法栈Native-Method-Stack" class="headerlink" title="本地方法栈Native Method Stack"></a>本地方法栈Native Method Stack</h2><p>本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。</p><h2 id="java内存模型-jmm"><a href="#java内存模型-jmm" class="headerlink" title="java内存模型 jmm"></a>java内存模型 jmm</h2><p>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。<br><strong>工作内存线程独享，主内存线程共享</strong></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://www.chenxun.wiki/2023062010082/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="陈公子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="陈公子的博客"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | 陈公子的博客"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2023062010082/" class="post-title-link" itemprop="url">dubbo源码研究之config-spring模块</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-06-20 05:58:06" itemprop="dateCreated datePublished" datetime="2023-06-20T05:58:06+00:00">2023-06-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-05 02:48:12" itemprop="dateModified" datetime="2023-12-05T02:48:12+00:00">2023-12-05</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="dubbo源码研究之config-spring模块"><a href="#dubbo源码研究之config-spring模块" class="headerlink" title="dubbo源码研究之config-spring模块"></a>dubbo源码研究之config-spring模块</h1><p>dubbo-config-spring模块是dubbo-config的Extension。</p><img src="/2023062010082/1.png" title="image"><p>Dubbo的扩展点加载从JDK标准的SPI(Service Provider Interface)扩展点发现机制加强而来。<br>Dubbo改进了JDK标准的SPI的以下问题：<br>JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。<br>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的ScriptEngine，通过getName();获取脚本类型的名称，<br>但如果RubyScriptEngine因为所依赖的jruby.jar不存在，导致RubyScriptEngine类加载失败，这个失败原因被吃掉了，和ruby对应不起来，<br>当用户执行ruby脚本时，会报不支持ruby，而不是真正失败的原因。<br>增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。<br>dubbo的spi约定：在扩展类的jar包内，放置扩展点配置文件：META-INF&#x2F;dubbo&#x2F;接口全限定名，内容为：配置名&#x3D;扩展实现类全限定名，多个实现类用换行符分隔。</p><figure class="highlight java"><figcaption><span>schema.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Get extension. </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type object type. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name object name. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> object instance. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">&lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo的扩展点接口ExtensionFactory ，该接口有三个实现</p><img src="/2023062010082/2.png" title="image"><p>dubbo的扩展实现的具体类是ExtensionLoader。<br>ExtensionLoader加载扩展点时，会检查扩展点的属性（通过set方法判断），如该属性是扩展点类型，则会注入扩展点对象。<br>因为注入时不能确定使用哪个扩展点（在使用时确定），所以注入的是一个自适应扩展（一个代理）。自适应扩展点调用时，选取一个真正的扩展点，并代理到其上完成调用。<br>Dubbo是根据调用方法参数（上面有调用哪个扩展点的信息）来选取一个真正的扩展点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">Class&lt;?&gt; clazz = getExtensionClasses().get(name);  </span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> findException(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());  </span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);  </span><br><span class="line">        &#125;  </span><br><span class="line">        injectExtension(instance);  </span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;  </span><br><span class="line"><span class="keyword">if</span> (wrapperClasses != <span class="literal">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;  </span><br><span class="line">instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> instance;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance(name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +  </span><br><span class="line">type + <span class="string">&quot;)  could not be instantiated: &quot;</span> + t.getMessage(), t);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (objectFactory != <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;  </span><br><span class="line"><span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>)  </span><br><span class="line">&amp;&amp; method.getParameterTypes().length == <span class="number">1</span>  </span><br><span class="line">&amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;  </span><br><span class="line">Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);  </span><br><span class="line"><span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;  </span><br><span class="line">method.invoke(instance, object);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">logger.error(<span class="string">&quot;fail to inject via method &quot;</span> + method.getName()  </span><br><span class="line">+ <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">logger.error(e.getMessage(), e);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出ExtensionLoader持有某一类扩展点的所有扩展，并且扩展以class为key，一个扩展类只有一个实例。<br>如果扩展点使用了Adaptive则会通过字节码生成一个自适应的扩展类。<br>通过createAdaptiveExtensionClassCode方法返回class的code，然后通过Compiler接口返回class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Compiler. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> william.liangf</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Compile java source code.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> code Java source code</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> classLoader TODO</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Compiled class</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Compiler dubbo支持jdk和Javassist两种实现，特别注意一点，JdkCompiler的java版本通过硬编码指定版本为1.6。<br>JdkCompiler首先通过JavaFileObject接口生成java文件，然后通过JavaCompiler接口编译成class文件，最后通过ClassLoader加载生成的class文件。<br>spring名称空间扩展<br>dubbo通过扩展spring的名称空间来读取xml配置。<br>dubbo.xsd是spring schma的扩展文件。作用是定义相关xml元素和名称空间。<br>spring.handlers,spring.schemas是spring在解析xml的时候根据spi机制读取对象的NamespaceHandler和xsd文件位置。<br>很多程序猿使用dubbo开发的时候，会发现ide工具报错，因为xml上面dubbo名称空间的链接打不开，其实这个报错可以无视的，<br>因为spring解析的xml的时候这个网络地址其实是指向spi配置文件里面的一个java类。<br>spring.handlers</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure><p>DubboNamespaceHandler则注册了相关自定义元素的解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * DubboNamespaceHandler</span><br><span class="line"> * </span><br><span class="line"> * @author william.liangf</span><br><span class="line"> * @export</span><br><span class="line">*/  </span><br><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">static &#123;  </span><br><span class="line">Version.checkDuplicate(DubboNamespaceHandler.class);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void init() &#123;  </span><br><span class="line">registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));  </span><br><span class="line">registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));  </span><br><span class="line">registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">陈公子</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/ChenXun1989" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},dialog:{enable:!0,hitokoto:!0},log:!1})</script></body></html>